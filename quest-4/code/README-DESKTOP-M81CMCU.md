# Code Readme
## newMerge (udp_client.c)
*Most component in the code are parallel task, each function will be the header in the following section.*

### udp_client_task()
This task initializes the UDP communication with the node server to control the rover via wifi. The task changes a global variable to drive or stop the rover on command.

### timer_example_evt_task()
This initiates a timer task to find the difference in time for each interrupt. The timer is used in unison with "countPuleses" to determine pulses over difference of time to find wheelspeed.

### countPuleses()
This counts the number of pulses from the IR sensor to determine speed of the wheels. This is then printed on the i2c Adafruit display

### front_lid()
This function is responsible of controlling both the front and back microLIDAR, where it reads into the register datas to find the distance. This is done by combining values from the register, where the high byte gets left shifted by 8 and OR'ed with the low byte. The distance is used to do PID and steer the rover.

### F_Lidar()
This function uses i2c-based LIDAR to find the distance from the rover to the nearest wall. The data is read by using i2c register read functions, which retrieves a high and low byte. The same bitwise operation is performed: the highbyte is left shifted by 8 and OR'ed with the low byte. The distance is used to stop the rover before hitting a wall.

### esc_start()
This is what controls the wheel's speed, it first gets calibrated and then regulated at a constant value so the rover's speed is maintained around 0.15 m/s.

### app_main()
This function is the main function that controls the rover's steering, where it uses "servo_per_degree_init()" to convert a desired angle to pulse width in us. This is then used to control the PWM for the servo to turn. The angle is determined by the PID of the rover's distance from the nearest side wall.


## Node Q3
*All packages are in node_modules*
### index.js
The basis of this node server uses dgram, and it listens to the ESP32 for data and sends information that will get parsed by "udp_client_task()" to start or stop the rover.
The data is generated by a front-end html webpage, with a start and stop button. Clicking the buttons will trigger an emit event through socket to the node server and back to the rover.

### index.html
Basic HTML with two buttons, one labelled "Run" and one labelled "Stop". Clicking both buttons triggers a socket emit event.
