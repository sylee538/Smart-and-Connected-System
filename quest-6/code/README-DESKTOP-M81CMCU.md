# Code Readme
## Quest6Code (udp_client.c)
*Most component in the code are parallel task, each function will be the header in the following section.*

### front_lid()
This task initiates the **UART_NUM_0** for the MicroLidar to find the distance, this is done by reading the registers and finding the right hex starter 0x59. The following hex numbers are the distances.

### sensors()
This manages an ADC conversion for the Ultrasonic sensor, which converts the voltage into distance and saves it in a global variable. The distance read will be used in controlling the rover's logic, where the rover will stop or start depending on how close the rover is to the wall.

### rx_task_ir()
This function uses UART to read from **UART_NUM_1**, which is connected to the IR receiver. This will receive the IR beacon signal and use the given **checksum()** function to ensure the data is correct. If so, a **boolean variable automatic** will be set true if green and allow driving logic, vice versa for red.

### esc_start()
This is what controls the wheel's speed, it first gets calibrated and then regulated at a constant value so the rover's speed is maintained around 0.15 m/s. A global **boolean variable drive** controls whether the car starts or stops, this is determined by the reading from the ultrasonic sensor. This logic is disabled if the beacon returns red.

### servo_start()
This function is the main function that controls the rover's steering, where it uses "servo_per_degree_init()" to convert a desired angle to pulse width in us. This is then used to control the PWM for the servo to turn. The angle is determined by the PID of the rover's distance from the nearest side wall.

### app_main()
This manages all the RTOS tasks separately, the while loop has the code that manages the LIDAR reading, which uses I2C to read registers to find the distance.

## FrontEnd
*All packages are in node_modules*
### index.html
We were able to display real-time live webcam on our html by connecting html to ip address of the raspberry pi, which the webcam is connected to.

When a stop button on the web is pressed, function stop() sends 0(direciton) to udp client and stops the crawler from moving.

When forward button on the web is pressed, function drive_forward() sends 1(direciton) to udp client and drives the crawler forward.

When left button on the web is pressed, function turn_left() sends 2(direciton) to udp client and turns the crawler to the left.

When right button on the web is pressed, function turn_right() sends 3(direciton) to udp client and turns the crawler to the right.

When backward button on the web is pressed, function drive_backward() sends 4(direciton) to udp client and drives the crawler backwards.

### node.js
The basics of this node server uses dgram, and it listens to the ESP32 for data and
sends information that will get parsed by "udp_client_task()" to drive the crawler.
The data is generated by a front-end html webpage, with 5 buttons. Clicking the buttons
will trigger an emit even through socket to the node server and then to the crawler.
